//@ts-nocheck
/**
 * This file and any referenced files were automatically generated by @cosmology/telescope@1.8.3
 * DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain
 * and run the transpile command or npm scripts command that is used to regenerate this bundle.
 */
import { encodeBase64, decodeBase64 } from '@endo/base64';
// use Endo for broader compatibility
export const bytesFromBase64 = decodeBase64;
export const base64FromBytes = encodeBase64;
export function omitDefault(input) {
    if (typeof input === 'string') {
        return input === '' ? undefined : input;
    }
    if (typeof input === 'number') {
        return input === 0 ? undefined : input;
    }
    if (typeof input === 'boolean') {
        return input === false ? undefined : input;
    }
    if (typeof input === 'bigint') {
        return input === BigInt(0) ? undefined : input;
    }
    throw new Error(`Got unsupported type ${typeof input}`);
}
export function toDuration(duration) {
    return {
        seconds: BigInt(Math.floor(parseInt(duration) / 1000000000)),
        nanos: parseInt(duration) % 1000000000,
    };
}
export function fromDuration(duration) {
    return (parseInt(duration.seconds.toString()) * 1000000000 +
        duration.nanos).toString();
}
export function isSet(value) {
    return value !== null && value !== undefined;
}
export function isObject(value) {
    return typeof value === 'object' && value !== null;
}
export const setPaginationParams = (options, pagination) => {
    if (!pagination) {
        return options;
    }
    if (typeof pagination?.countTotal !== 'undefined') {
        options.params['pagination.count_total'] = pagination.countTotal;
    }
    if (typeof pagination?.key !== 'undefined') {
        // String to Uint8Array
        // let uint8arr = new Uint8Array(Buffer.from(data,'base64'));
        // Uint8Array to String
        options.params['pagination.key'] = Buffer.from(pagination.key).toString('base64');
    }
    if (typeof pagination?.limit !== 'undefined') {
        options.params['pagination.limit'] = pagination.limit.toString();
    }
    if (typeof pagination?.offset !== 'undefined') {
        options.params['pagination.offset'] = pagination.offset.toString();
    }
    if (typeof pagination?.reverse !== 'undefined') {
        options.params['pagination.reverse'] = pagination.reverse;
    }
    return options;
};
export function toTimestamp(date) {
    const seconds = numberToLong(date.getTime() / 1_000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return {
        seconds,
        nanos,
    };
}
export function fromTimestamp(t) {
    let millis = Number(t.seconds) * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
const timestampFromJSON = (object) => {
    return {
        seconds: isSet(object.seconds)
            ? BigInt(object.seconds.toString())
            : BigInt(0),
        nanos: isSet(object.nanos) ? Number(object.nanos) : 0,
    };
};
export function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return toTimestamp(o);
    }
    else if (typeof o === 'string') {
        return toTimestamp(new Date(o));
    }
    else {
        return timestampFromJSON(o);
    }
}
function numberToLong(number) {
    return BigInt(Math.trunc(number));
}
// START agoric-sdk patch
// The largest value we need is 18 (Ether).
const maxFractionalDigits = 30;
/**
 * A type for arbitrary precision, non-negative decimals.
 *
 * Instances of this class are immutable.
 */
export class Decimal {
    static fromUserInput(input, fractionalDigits) {
        Decimal.verifyFractionalDigits(fractionalDigits);
        const badCharacter = input.match(/[^0-9.]/);
        if (badCharacter) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            throw new Error(`Invalid character at position ${badCharacter.index + 1}`);
        }
        let whole;
        let fractional;
        if (input === '') {
            whole = '0';
            fractional = '';
        }
        else if (input.search(/\./) === -1) {
            // integer format, no separator
            whole = input;
            fractional = '';
        }
        else {
            const parts = input.split('.');
            switch (parts.length) {
                case 0:
                case 1:
                    throw new Error('Fewer than two elements in split result. This must not happen here.');
                case 2:
                    if (!parts[1])
                        throw new Error('Fractional part missing');
                    whole = parts[0];
                    fractional = parts[1].replace(/0+$/, '');
                    break;
                default:
                    throw new Error('More than one separator found');
            }
        }
        if (fractional.length > fractionalDigits) {
            throw new Error('Got more fractional digits than supported');
        }
        const quantity = `${whole}${fractional.padEnd(fractionalDigits, '0')}`;
        return new Decimal(quantity, fractionalDigits);
    }
    static fromAtomics(atomics, fractionalDigits) {
        Decimal.verifyFractionalDigits(fractionalDigits);
        return new Decimal(atomics, fractionalDigits);
    }
    static verifyFractionalDigits(fractionalDigits) {
        if (!Number.isInteger(fractionalDigits))
            throw new Error('Fractional digits is not an integer');
        if (fractionalDigits < 0)
            throw new Error('Fractional digits must not be negative');
        if (fractionalDigits > maxFractionalDigits) {
            throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);
        }
    }
    get atomics() {
        return this.data.atomics.toString();
    }
    get fractionalDigits() {
        return this.data.fractionalDigits;
    }
    data;
    constructor(atomics, fractionalDigits) {
        if (!atomics.match(/^[0-9]+$/)) {
            throw new Error('Invalid string format. Only non-negative integers in decimal representation supported.');
        }
        this.data = {
            atomics: BigInt(atomics),
            fractionalDigits: fractionalDigits,
        };
    }
    toString() {
        const factor = BigInt(10) ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) {
            return whole.toString();
        }
        else {
            const fullFractionalPart = fractional
                .toString()
                .padStart(this.data.fractionalDigits, '0');
            const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, '');
            return `${whole.toString()}.${trimmedFractionalPart}`;
        }
    }
}
// END agoric-sdk patch
//# sourceMappingURL=helpers.js.map