import fs from 'fs';
import { E } from '@endo/far';
import { deeplyFulfilled, makeMarshal } from '@endo/marshal';
import { decodeToJustin } from '@endo/marshal/src/marshal-justin.js';

import { makeCoreProposalBehavior } from './coreProposalBehavior.js';
import { createBundles } from './createBundles.js';

const { serialize } = makeMarshal();
const stringify = (x, pretty = undefined) =>
  decodeToJustin(JSON.parse(serialize(harden(x)).body), pretty);

export const makeWriteCoreProposal = (
  homeP,
  endowments,
  { getBundlerMaker, installInPieces },
) => {
  const { board, zoe } = E.get(homeP);
  const { bundleSource, pathResolve } = endowments;

  let bundlerCache;
  const getBundler = () => {
    if (!bundlerCache) {
      bundlerCache = E(getBundlerMaker()).makeBundler({
        zoe,
      });
    }
    return bundlerCache;
  };

  const mergeProposalPermit = async (proposal, additionalManifest) => {
    const {
      sourceSpec,
      getManifestCall: [exportedGetManifest, ...manifestArgs],
    } = proposal;

    const manifestNs = await import(pathResolve(sourceSpec));

    // We only care about the manifest, not any restoreRef calls.
    const { manifest } = await manifestNs[exportedGetManifest](
      { restoreRef: x => `restoreRef:${x}` },
      ...manifestArgs,
    );

    // FIXME: later actually merge the manifest with additionalManifest for
    // minimalistic permit.
    console.log('TODO: would merge', { manifest, additionalManifest });
    return true;
  };

  const writeCoreProposal = async (filePrefix, proposalBuilder) => {
    // Install an entrypoint.
    const install = async (entrypoint, bundlePath) => {
      const bundler = getBundler();
      let bundle;
      if (bundlePath) {
        const bundleCache = pathResolve(bundlePath);
        await createBundles([[pathResolve(entrypoint), bundleCache]]);
        const ns = await import(bundleCache);
        bundle = ns.default;
      } else {
        bundle = await bundleSource(pathResolve(entrypoint));
      }
      return installInPieces(bundle, bundler);
    };

    // Await a reference then publish to the board.
    const publishRef = async refP => {
      const ref = await refP;
      return E(board).getId(ref);
    };

    // Create the proposal structure.
    const proposal = await deeplyFulfilled(
      harden(proposalBuilder({ publishRef, install })),
    );
    const { sourceSpec, getManifestCall } = proposal;

    // Extract the top-level permit.
    const t = 'writeCoreProposal';
    const proposalPermit = await mergeProposalPermit(proposal, {
      $writeCoreProposal: {
        consume: { board: t },
        evaluateInstallation: t,
        installation: { produce: t },
        modules: { utils: { runModuleBehaviors: t } },
      },
    });

    // Get an install
    const manifestInstallRef = await publishRef(install(sourceSpec));

    const code = `\
// This is generated by writeCoreProposal; please edit!
/* eslint-disable */

const manifestInstallRef = ${stringify(manifestInstallRef)};
const getManifestCall = harden(${stringify(getManifestCall, true)});

// Make the behavior the completion value.
(${makeCoreProposalBehavior})({ manifestInstallRef, getManifestCall, E });
`;

    // end-of-line whitespace disrupts YAML formatting
    const trimmed = code.replace(/[\r\t ]+$/gm, '');

    const proposalPermitJsonFile = `${filePrefix}-permit.json`;
    console.log(`creating ${proposalPermitJsonFile}`);
    fs.writeFileSync(proposalPermitJsonFile, JSON.stringify(proposalPermit));

    const proposalJsFile = `${filePrefix}.js`;
    console.log(`creating ${proposalJsFile}`);
    fs.writeFileSync(proposalJsFile, trimmed);

    console.log(`\
You can now run a governance submission command like:
  agd tx gov submit-proposal swingset-core-eval ${proposalPermitJsonFile} ${proposalJsFile} \\
    --title="Enable <something>" --description="Evaluate ${proposalJsFile}" --deposit=1000000ubld \\
    --gas=auto --gas-adjustment=1.2
`);
  };

  return writeCoreProposal;
};
